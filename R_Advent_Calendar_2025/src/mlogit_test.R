# generated by ChatGPT on 2025-11-09
# 多項ロジットモデルの限界効果計算の例の計算:要検証
library(mlogit)
library(margins)

# サンプルデータ
df <- data.frame(
  id = rep(1:4, each = 3),
  mode = rep(c("car", "bus", "train"), times = 4),
  choice = c(1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),  # 1が選択肢
  time = c(30, 45, 50, 40, 30, 60, 50, 55, 35, 35, 50, 45),
  cost = c(400, 200, 500, 450, 180, 550, 500, 220, 480, 350, 210, 530)
)

# mlogit用に変換
mdata <- mlogit.data(df, choice = "choice", shape = "long",
                     alt.var = "mode")


model <- mlogit(choice ~ time + cost, data = mdata)
summary(model)

fitted_probs <- fitted(model)
head(fitted_probs)


#---- 前提 ----
# model : mlogit オブジェクト（mlogit::mlogit）
# mdata : mlogit用の long データ（mlogit.dataで作ったもの）
# ここでは 'alt' が選択肢名の列名（例: "car","bus","train"）
# 各行は個体i と代替 j の組合せ


#---- ユーティリティ関数 ----
#' 個体ごとの予測確率行列 P (n_individual x n_alternatives)
#' @param model mlogitオブジェクト
#' @param mdata mlogit用のlongデータ
#' @return 個体×代替の確率行列
get_pred_probs <- function(model, mdata) {
  # fitted() は mlogit で個行に対する確率を返す (行順は mdata と一致)
  probs_long <- fitted(model)   # ベクトル (長形式)
  # mdata$chid: choice id (個体), mdata$alt: alternative
  chid <- mdata$chid
  alt <- mdata$alt
  uniq_id <- unique(chid)
  alts <- unique(alt)
  pmat <- matrix(NA, nrow = length(uniq_id), ncol = length(alts),
                 dimnames = list(uniq_id, alts))
  # mdata 行順に probs_long 対応すると仮定
  for (i in seq_along(uniq_id)) {
    these <- which(chid == uniq_id[i])
    pmat[i, as.character(alt[these])] <- probs_long[these]
  }
  return(pmat)  # 行 = 個体, 列 = 代替
}

#' 代替特有変数 x_{il} の限界効果（係数が代替別か共通かを選ぶ）
#' @param model mlogitオブジェクト
#' @param mdata mlogit用のlongデータ
#' @param varname 変数名 (文字列, mdataの列名)
#' @param coef_list 推定係数（名前付）: mlcoef <- coef(model)
#' @param coef_by_alt 係数が代替別かどうか
#' @return 限界効果の配列と確率行列、変数行列のリスト
compute_me_alt_specific <- function(model, mdata, varname,
                                    coef_list, coef_by_alt = FALSE) {
  pmat <- get_pred_probs(model, mdata)
  chid <- mdata$chid
  alt <- mdata$alt
  uniq_id <- unique(chid)
  alts <- colnames(pmat)
  n_id <- nrow(pmat)
  n_alt <- ncol(pmat)

  # 変数値を行列化（行:個体, 列:代替）
  xmat <- matrix(NA, nrow = n_id, ncol = n_alt,
                 dimnames = list(uniq_id, alts))
  for (i in seq_along(uniq_id)) {
    these <- which(chid == uniq_id[i])
    xmat[i, as.character(alt[these])] <- mdata[[varname]][these]
  }

  # 係数を準備
  if (!coef_by_alt) {
    # 共通係数を想定（名前の付け方は model に依存）
    beta <- as.numeric(coef_list[[varname]])
    # 列ごとに同じ係数
    beta_vec <- rep(beta, n_alt)
  } else {
    # 代替ごとに異なる係数がある場合
    # （例: "time:car","time:bus",... のような命名）
    beta_vec <- sapply(alts, function(a) {
      nm <- paste0(varname, ":", a)    # 実際の名前はモデル式に依存
      if (!is.null(coef_list[nm])) coef_list[[nm]] else NA
    })
  }

  # 個体ごと・代替ごとの限界効果を計算
  me <- array(NA, dim = c(n_id, n_alt, n_alt),
              dimnames = list(uniq_id, alts, alts))
  # me[i, j, l] = ∂P_{ij} / ∂ x_{il}
  for (i in seq_len(n_id)) {
    pi <- pmat[i, ]          # 長さ n_alt
    for (j in seq_len(n_alt)) {
      for (l in seq_len(n_alt)) {
        ijl <- ifelse(j == l, 1, 0)
        me[i, j, l] <- beta_vec[l] * pi[j] * (ijl - pi[l])
      }
    }
  }
  return(list(ME = me, P = pmat, x = xmat))
}

#' 個体特有変数 z_i の限界効果（選択肢ごとに係数 gamma_j があるケース）
#' @param model mlogitオブジェクト
#' @param mdata mlogit用のlongデータ
#' @param zname 変数名
#' @param gamma_by_alt gamma_jの名前付きベクトル (names must be alt names)
#' @return 限界効果行列と確率行列のリスト
compute_me_indiv_specific <- function(model, mdata, zname, gamma_by_alt) {
  # gamma_by_alt: named vector of gamma_j (names must be alt names)
  pmat <- get_pred_probs(model, mdata)
  uniq_id <- rownames(pmat)
  n_id <- nrow(pmat)
  n_alt <- ncol(pmat)
  me <- matrix(NA, nrow = n_id, ncol = n_alt,
               dimnames = list(uniq_id, colnames(pmat)))
  for (i in seq_len(n_id)) {
    pi <- pmat[i, ]
    mean_gamma <- sum(pi * gamma_by_alt)
    for (j in seq_len(n_alt)) {
      me[i, j] <- pi[j] * (gamma_by_alt[j] - mean_gamma)
    }
  }
  return(list(ME = me, P = pmat))
}

# model を推定済みとする。
# coef_list <- coef(model)  # 係数ベクトル（名前付）

# 代替特有の 'time' に対する ME（共通係数と仮定）
res <- compute_me_alt_specific(model, mdata, varname = "time",
                               coef_list = coef(model), coef_by_alt = FALSE)
me_array <- res$ME   # [個体, j, l] の配列
pmat <- res$P

# 個体 i の「自身の代替 (l) の time 増加が各選択肢 j の確率に与える影響」
# を見る例:
i_idx <- 1
me_array[i_idx, , ]   # 行列: j x l

# 平均限界効果 (各個体の自分の選択肢に対する変化 = j==l 部分の平均)
# 例えば「自分の代替の time を1増加させたときの当該代替の確率変化の平均」
ame_self_time <- mean(sapply(seq_len(nrow(me_array)), function(ii) {
  sum(diag(me_array[ii, , ]))  # diag = ∂P_{ij}/∂x_{ij} summed over j
}))


# ブートストラップによる標準誤差の推定
B <- 200
ame_boot <- numeric(0)
success_count <- 0
for(b in 1:B){
  ids <- sample(unique(df$id), replace = TRUE)
  bsamp_df <- do.call(rbind, lapply(ids, function(x) df[df$id == x, ]))
  bsamp_df$id <- rep(1:length(ids), each = 3)  # Re-index the id column
  # Add small noise to prevent singularity
  bsamp_df$time <- bsamp_df$time + rnorm(nrow(bsamp_df), 0, 0.01)
  bsamp_df$cost <- bsamp_df$cost + rnorm(nrow(bsamp_df), 0, 0.01)
  bsamp <- mlogit.data(bsamp_df, choice = "choice", shape = "long", alt.var = "mode")
  
  # Try to fit model with error handling
  model_b <- tryCatch({
    update(model, data = bsamp)
  }, error = function(e) {
    return(NULL)
  })
  
  if(!is.null(model_b)){
    res_b <- compute_me_alt_specific(model_b, bsamp, "time", coef(model_b), FALSE)
    ame_boot <- c(ame_boot, mean(
      sapply(
        seq_len(
          dim(res_b$ME)[1]),
           function(ii) {
             me_mat <- res_b$ME[ii, , ]
             if(is.matrix(me_mat) && nrow(me_mat) == ncol(me_mat)) {
               sum(diag(me_mat))
             } else {
               NA
             }
           }
           ), na.rm = TRUE
           ))
    success_count <- success_count + 1
  }
}
cat("Successfully converged:", success_count, "out of", B, "iterations\n")
se_ame <- sd(ame_boot)
se_ame

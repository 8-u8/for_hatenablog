# generated by ChatGPT on 2025-11-09
# 多項ロジットモデルの限界効果計算の例の計算：要検証

library(mlogit)
library(margins)

# サンプルデータ
df <- data.frame(
  id = rep(1:4, each=3),
  mode = rep(c("car", "bus", "train"), times=4),
  choice = c(1,0,0, 0,1,0, 0,0,1, 1,0,0),  # 1が選択肢
  time = c(30,45,50, 40,30,60, 50,55,35, 35,50,45),
  cost = c(400,200,500, 450,180,550, 500,220,480, 350,210,530)
)

# mlogit用に変換
mdata <- mlogit.data(df, choice="choice", shape="long", alt.var="mode")


model <- mlogit(choice ~ time + cost, data=mdata)
summary(model)

fitted_probs <- fitted(model)
head(fitted_probs)


#---- 前提 ----
# model : mlogit オブジェクト（mlogit::mlogit）
# mdata : mlogit用の long データ（mlogit.dataで作ったもの）
# ここでは 'alt' が選択肢名の列名（例: "car","bus","train"）
# 各行は個体i と代替 j の組合せ


#---- ユーティリティ関数 ----
# 1) 個体ごとの予測確率行列 P (n_individual x n_alternatives)
get_pred_probs <- function(model, mdata) {
  # fitted() は mlogit で個行に対する確率を返す (行順は mdata と一致)
  probs_long <- fitted(model)   # ベクトル (長形式)
  # mdata$chid: choice id (個体), mdata$alt: alternative
  chid <- mdata$chid
  alt  <- mdata$alt
  uniq_id <- unique(chid)
  alts <- unique(alt)
  Pmat <- matrix(NA, nrow = length(uniq_id), ncol = length(alts),
                 dimnames = list(uniq_id, alts))
  # mdata 行順に probs_long 対応すると仮定
  idx <- 1
  for(i in seq_along(uniq_id)) {
    these <- which(chid == uniq_id[i])
    Pmat[i, as.character(alt[these])] <- probs_long[these]
  }
  return(Pmat)  # 行 = 個体, 列 = 代替
}

# 2) 代替特有変数 x_{il} の限界効果（係数が代替別か共通かを選ぶ）
#    varname: 変数名 (文字列, mdataの列名)
#    coef_list: 推定係数（名前付）: mlcoef <- coef(model)
compute_me_alt_specific <- function(model, mdata, varname, coef_list, coef_by_alt = FALSE){
  Pmat <- get_pred_probs(model, mdata)
  chid <- mdata$chid
  alt <- mdata$alt
  uniq_id <- unique(chid)
  alts <- colnames(Pmat)
  n_id <- nrow(Pmat)
  n_alt <- ncol(Pmat)

  # 変数値を行列化（行:個体, 列:代替）
  xmat <- matrix(NA, nrow=n_id, ncol=n_alt, dimnames = list(uniq_id, alts))
  for(i in seq_along(uniq_id)){
    these <- which(chid == uniq_id[i])
    xmat[i, as.character(alt[these])] <- mdata[[varname]][these]
  }

  # 係数を準備
  if(!coef_by_alt){
    beta <- as.numeric(coef_list[[varname]]) # 共通係数を想定（名前の付け方は model に依存）
    # 列ごとに同じ係数
    beta_vec <- rep(beta, n_alt)
  } else {
    # 代替ごとに異なる係数がある場合（例: "time:car","time:bus",... のような命名）
    beta_vec <- sapply(alts, function(a){
      nm <- paste0(varname, ":", a)    # 実際の名前はモデル式に依存
      if(!is.null(coef_list[nm])) coef_list[[nm]] else NA
    })
  }

  # 個体ごと・代替ごとの限界効果を計算
  ME <- array(NA, dim=c(n_id, n_alt, n_alt),
              dimnames = list(uniq_id, alts, alts))
  # ME[i, j, l] = ∂P_{ij} / ∂ x_{il}
  for(i in 1:n_id){
    Pi <- Pmat[i, ]          # 長さ n_alt
    for(j in 1:n_alt){
      for(l in 1:n_alt){
        Ijl <- ifelse(j==l, 1, 0)
        ME[i,j,l] <- beta_vec[l] * Pi[j] * (Ijl - Pi[l])
      }
    }
  }
  return(list(ME = ME, P = Pmat, x = xmat))
}

# 3) 個体特有変数 z_i の限界効果（選択肢ごとに係数 gamma_j があるケース）
compute_me_indiv_specific <- function(model, mdata, zname, gamma_by_alt){
  # gamma_by_alt: named vector of gamma_j (names must be alt names)
  Pmat <- get_pred_probs(model, mdata)
  uniq_id <- rownames(Pmat)
  n_id <- nrow(Pmat)
  n_alt <- ncol(Pmat)
  ME <- matrix(NA, nrow = n_id, ncol = n_alt, dimnames = list(uniq_id, colnames(Pmat)))
  for(i in 1:n_id){
    Pi <- Pmat[i, ]
    mean_gamma <- sum(Pi * gamma_by_alt)
    for(j in 1:n_alt){
      ME[i,j] <- Pi[j] * (gamma_by_alt[j] - mean_gamma)
    }
  }
  return(list(ME = ME, P = Pmat))
}

# model を推定済みとする。
# coef_list <- coef(model)  # 係数ベクトル（名前付）

# 代替特有の 'time' に対する ME（共通係数と仮定）
res <- compute_me_alt_specific(model, mdata, varname="time",
                               coef_list=coef(model), coef_by_alt = FALSE)
ME_array <- res$ME   # [個体, j, l] の配列
Pmat <- res$P

# 個体 i の「自身の代替 (l) の time 増加が各選択肢 j の確率に与える影響」
# を見る例:
i_idx <- 1
ME_array[i_idx, , ]   # 行列: j x l

# 平均限界効果 (各個体の自分の選択肢に対する変化 = j==l 部分の平均)
# 例えば「自分の代替の time を1増加させたときの当該代替の確率変化の平均」
AME_self_time <- mean(sapply(1:nrow(ME_array), function(ii) {
  sum(diag(ME_array[ii,,]))  # diag = ∂P_{ij}/∂x_{ij} summed over j
}))
